import os
import json
from langchain.prompts import ChatPromptTemplate
from langchain_openai import ChatOpenAI
from constant.all_prompt import CAREER_ROADMAP_PROMPT

def generate_career_roadmap(skill_gaps, preferred_career_track, timeframe):
    """
    Generate a comprehensive career roadmap based on skill gaps, career track, and timeframe.
    
    Args:
        skill_gaps (str): The identified skill gaps for the user
        preferred_career_track (str): The user's preferred career track/role
        timeframe (str): The timeframe for the roadmap (e.g., "3 months", "6 months", "1 year")
        
    Returns:
        dict: A dictionary containing:
            - topic_to_learn (list): Array of topics to learn
            - plan (list): Array of arrays, where each inner array represents a phase
            - projectideas (list): Array of project ideas
            - applyon (str): When to start applying for jobs
    """
    try:
        # Validate inputs
        if not skill_gaps or not skill_gaps.strip():
            raise ValueError("skill_gaps is required")
        if not preferred_career_track or not preferred_career_track.strip():
            raise ValueError("preferred_career_track is required")
        if not timeframe or not timeframe.strip():
            raise ValueError("timeframe is required")
        
        # Create prompt template
        prompt_template = ChatPromptTemplate.from_template(CAREER_ROADMAP_PROMPT)
        prompt = prompt_template.format(
            skill_gaps=skill_gaps,
            preferred_career_track=preferred_career_track,
            timeframe=timeframe
        )

        # Use ChatOpenAI with JSON mode
        llm = ChatOpenAI(
            model_name="gpt-4o",
            temperature=0.3,
            streaming=False,
            max_tokens=3000,
            openai_api_key=os.environ.get('OPENAI_API_KEY'),
            model_kwargs={"response_format": {"type": "json_object"}}
        )

        # Generate response
        response = llm.invoke(prompt)

        # Parse JSON response
        try:
            result = json.loads(response.content)
            
            # Validate and ensure correct types
            topic_to_learn = result.get("topic_to_learn", [])
            plan = result.get("plan", [])
            projectideas = result.get("projectideas", [])
            applyon = result.get("applyon", "")
            
            # Ensure arrays are lists
            if not isinstance(topic_to_learn, list):
                topic_to_learn = [topic_to_learn] if topic_to_learn else []
            if not isinstance(plan, list):
                plan = [plan] if plan else []
            if not isinstance(projectideas, list):
                projectideas = [projectideas] if projectideas else []
            
            # Ensure plan is array of arrays
            validated_plan = []
            for phase in plan:
                if isinstance(phase, list):
                    validated_plan.append(phase)
                elif isinstance(phase, str):
                    validated_plan.append([phase])
                else:
                    # Skip invalid phases
                    continue
            
            # Ensure applyon is a string
            if not isinstance(applyon, str):
                applyon = str(applyon) if applyon else ""
            
            # Validate that all topics in plan exist in topic_to_learn
            all_plan_topics = []
            for phase in validated_plan:
                all_plan_topics.extend(phase)
            
            # Filter out any topics in plan that don't exist in topic_to_learn
            # (This is a safety check, but we'll keep the plan as generated by AI)
            
            return {
                "topic_to_learn": topic_to_learn,
                "plan": validated_plan,
                "projectideas": projectideas,
                "applyon": applyon
            }
            
        except json.JSONDecodeError as e:
            print(f"JSON parsing error: {e}, response content: {response.content}")
            raise Exception(f"Failed to parse AI response: {str(e)}")
        except Exception as e:
            print(f"Error processing response: {e}")
            raise e

    except Exception as e:
        import traceback
        print(f"Error in generate_career_roadmap: {str(e)}")
        print(traceback.format_exc())
        raise e

